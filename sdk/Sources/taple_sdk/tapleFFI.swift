// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(tapleFFI)
import tapleFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_taple_ffi_b33d_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_taple_ffi_b33d_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, F: FfiConverter>
    (_ errorFfiConverter: F.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T
    where F.SwiftType: Error, F.FfiType == RustBuffer
    {
    try makeRustCall(callback, errorHandler: { return try errorFfiConverter.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
        case CALL_SUCCESS:
            return returnedVal

        case CALL_ERROR:
            throw try errorHandler(callStatus.errorBuf)

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}


public protocol ShutdownSignalProtocol {
    func `shutdown`() throws
    
}

public class ShutdownSignal: ShutdownSignalProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_taple_ffi_b33d_ShutdownSignal_object_free(pointer, $0) }
    }

    

    
    public func `shutdown`() throws {
        try
    rustCallWithError(FfiConverterTypeShutdownError.self) {
    taple_ffi_b33d_ShutdownSignal_shutdown(self.pointer, $0
    )
}
    }
    
}


public struct FfiConverterTypeShutdownSignal: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ShutdownSignal

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShutdownSignal {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ShutdownSignal, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ShutdownSignal {
        return ShutdownSignal(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ShutdownSignal) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol SubjectBuilderProtocol {
    func `withName`(`name`: String) throws
    func `withNamespace`(`namespace`: String) throws
    func `build`(`governanceId`: String, `schemaId`: String) throws -> UserSubject
    
}

public class SubjectBuilder: SubjectBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_taple_ffi_b33d_SubjectBuilder_object_free(pointer, $0) }
    }

    

    
    public func `withName`(`name`: String) throws {
        try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_SubjectBuilder_with_name(self.pointer, 
        FfiConverterString.lower(`name`), $0
    )
}
    }
    public func `withNamespace`(`namespace`: String) throws {
        try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_SubjectBuilder_with_namespace(self.pointer, 
        FfiConverterString.lower(`namespace`), $0
    )
}
    }
    public func `build`(`governanceId`: String, `schemaId`: String) throws -> UserSubject {
        return try FfiConverterTypeUserSubject.lift(
            try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_SubjectBuilder_build(self.pointer, 
        FfiConverterString.lower(`governanceId`), 
        FfiConverterString.lower(`schemaId`), $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeSubjectBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SubjectBuilder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubjectBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SubjectBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SubjectBuilder {
        return SubjectBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SubjectBuilder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol TapleAPIProtocol {
    func `getRequest`(`requestId`: String) throws -> TapleRequest
    func `externalRequest`(`eventRequest`: TapleSignedEventRequest) throws -> String
    func `getSubject`(`subjectId`: String) throws -> UserSubject
    func `addPreauthorizeSubject`(`subjectId`: String, `providers`: [String]) throws
    func `addKeys`(`derivator`: String) throws -> String
    func `getGovernances`(`namespace`: String, `from`: String?, `quantity`: Int64?) throws -> [UserSubject]
    func `getSubjects`(`namespace`: String, `from`: String?, `quantity`: Int64?) throws -> [UserSubject]
    func `getSubjectsByGovernance`(`governanceId`: String, `from`: String?, `quantity`: Int64?) throws -> [UserSubject]
    func `getEvents`(`subjectId`: String, `from`: Int64?, `quantity`: Int64?) throws -> [TapleSignedEvent]
    func `getEvent`(`subjectId`: String, `sn`: UInt64) throws -> TapleSignedEvent
    func `getAllAllowedSubjectsAndProviders`(`from`: String?, `quantity`: Int64?) throws -> [SubjectAndProviders]
    func `getValidationProof`(`subjectId`: String) throws -> ValidationProofAndSignatures
    func `signEventRequest`(`eventRequest`: EventRequestType) throws -> TapleSignature
    
}

public class TapleApi: TapleAPIProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_taple_ffi_b33d_TapleAPI_object_free(pointer, $0) }
    }

    

    
    public func `getRequest`(`requestId`: String) throws -> TapleRequest {
        return try FfiConverterTypeTapleRequest.lift(
            try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_TapleAPI_get_request(self.pointer, 
        FfiConverterString.lower(`requestId`), $0
    )
}
        )
    }
    public func `externalRequest`(`eventRequest`: TapleSignedEventRequest) throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_TapleAPI_external_request(self.pointer, 
        FfiConverterTypeTapleSignedEventRequest.lower(`eventRequest`), $0
    )
}
        )
    }
    public func `getSubject`(`subjectId`: String) throws -> UserSubject {
        return try FfiConverterTypeUserSubject.lift(
            try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_TapleAPI_get_subject(self.pointer, 
        FfiConverterString.lower(`subjectId`), $0
    )
}
        )
    }
    public func `addPreauthorizeSubject`(`subjectId`: String, `providers`: [String]) throws {
        try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_TapleAPI_add_preauthorize_subject(self.pointer, 
        FfiConverterString.lower(`subjectId`), 
        FfiConverterSequenceString.lower(`providers`), $0
    )
}
    }
    public func `addKeys`(`derivator`: String) throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_TapleAPI_add_keys(self.pointer, 
        FfiConverterString.lower(`derivator`), $0
    )
}
        )
    }
    public func `getGovernances`(`namespace`: String, `from`: String?, `quantity`: Int64?) throws -> [UserSubject] {
        return try FfiConverterSequenceTypeUserSubject.lift(
            try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_TapleAPI_get_governances(self.pointer, 
        FfiConverterString.lower(`namespace`), 
        FfiConverterOptionString.lower(`from`), 
        FfiConverterOptionInt64.lower(`quantity`), $0
    )
}
        )
    }
    public func `getSubjects`(`namespace`: String, `from`: String?, `quantity`: Int64?) throws -> [UserSubject] {
        return try FfiConverterSequenceTypeUserSubject.lift(
            try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_TapleAPI_get_subjects(self.pointer, 
        FfiConverterString.lower(`namespace`), 
        FfiConverterOptionString.lower(`from`), 
        FfiConverterOptionInt64.lower(`quantity`), $0
    )
}
        )
    }
    public func `getSubjectsByGovernance`(`governanceId`: String, `from`: String?, `quantity`: Int64?) throws -> [UserSubject] {
        return try FfiConverterSequenceTypeUserSubject.lift(
            try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_TapleAPI_get_subjects_by_governance(self.pointer, 
        FfiConverterString.lower(`governanceId`), 
        FfiConverterOptionString.lower(`from`), 
        FfiConverterOptionInt64.lower(`quantity`), $0
    )
}
        )
    }
    public func `getEvents`(`subjectId`: String, `from`: Int64?, `quantity`: Int64?) throws -> [TapleSignedEvent] {
        return try FfiConverterSequenceTypeTapleSignedEvent.lift(
            try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_TapleAPI_get_events(self.pointer, 
        FfiConverterString.lower(`subjectId`), 
        FfiConverterOptionInt64.lower(`from`), 
        FfiConverterOptionInt64.lower(`quantity`), $0
    )
}
        )
    }
    public func `getEvent`(`subjectId`: String, `sn`: UInt64) throws -> TapleSignedEvent {
        return try FfiConverterTypeTapleSignedEvent.lift(
            try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_TapleAPI_get_event(self.pointer, 
        FfiConverterString.lower(`subjectId`), 
        FfiConverterUInt64.lower(`sn`), $0
    )
}
        )
    }
    public func `getAllAllowedSubjectsAndProviders`(`from`: String?, `quantity`: Int64?) throws -> [SubjectAndProviders] {
        return try FfiConverterSequenceTypeSubjectAndProviders.lift(
            try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_TapleAPI_get_all_allowed_subjects_and_providers(self.pointer, 
        FfiConverterOptionString.lower(`from`), 
        FfiConverterOptionInt64.lower(`quantity`), $0
    )
}
        )
    }
    public func `getValidationProof`(`subjectId`: String) throws -> ValidationProofAndSignatures {
        return try FfiConverterTypeValidationProofAndSignatures.lift(
            try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_TapleAPI_get_validation_proof(self.pointer, 
        FfiConverterString.lower(`subjectId`), $0
    )
}
        )
    }
    public func `signEventRequest`(`eventRequest`: EventRequestType) throws -> TapleSignature {
        return try FfiConverterTypeTapleSignature.lift(
            try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_TapleAPI_sign_event_request(self.pointer, 
        FfiConverterTypeEventRequestType.lower(`eventRequest`), $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeTapleApi: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TapleApi

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapleApi {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TapleApi, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TapleApi {
        return TapleApi(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TapleApi) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol TapleNodeProtocol {
    func `getApi`()  -> TapleApi
    func `getShutdownHandler`()  -> ShutdownSignal
    func `receiveBlocking`() throws -> TapleNotification
    func `dropNotifications`() throws
    func `handleNotifications`(`handler`: NotificationHandlerInterface) throws
    func `getSubjectBuilder`()  -> SubjectBuilder
    func `shutdownGracefully`() throws
    
}

public class TapleNode: TapleNodeProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_taple_ffi_b33d_TapleNode_object_free(pointer, $0) }
    }

    

    
    public func `getApi`()  -> TapleApi {
        return try! FfiConverterTypeTapleApi.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_TapleNode_get_api(self.pointer, $0
    )
}
        )
    }
    public func `getShutdownHandler`()  -> ShutdownSignal {
        return try! FfiConverterTypeShutdownSignal.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_TapleNode_get_shutdown_handler(self.pointer, $0
    )
}
        )
    }
    public func `receiveBlocking`() throws -> TapleNotification {
        return try FfiConverterTypeTapleNotification.lift(
            try
    rustCallWithError(FfiConverterTypeNotificationError.self) {
    taple_ffi_b33d_TapleNode_receive_blocking(self.pointer, $0
    )
}
        )
    }
    public func `dropNotifications`() throws {
        try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_TapleNode_drop_notifications(self.pointer, $0
    )
}
    }
    public func `handleNotifications`(`handler`: NotificationHandlerInterface) throws {
        try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_TapleNode_handle_notifications(self.pointer, 
        FfiConverterCallbackInterfaceNotificationHandlerInterface.lower(`handler`), $0
    )
}
    }
    public func `getSubjectBuilder`()  -> SubjectBuilder {
        return try! FfiConverterTypeSubjectBuilder.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_TapleNode_get_subject_builder(self.pointer, $0
    )
}
        )
    }
    public func `shutdownGracefully`() throws {
        try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_TapleNode_shutdown_gracefully(self.pointer, $0
    )
}
    }
    
}


public struct FfiConverterTypeTapleNode: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TapleNode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapleNode {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TapleNode, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TapleNode {
        return TapleNode(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TapleNode) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol UserGovernanceProtocol {
    func `getMembers`() throws -> [String]
    func `getSchemas`() throws -> [Schema]
    func `getPolicies`() throws -> [Policy]
    func `getRoles`() throws -> [Role]
    func `refresh`() throws
    func `getSubjectId`()  -> String
    func `getGovernanceId`()  -> String
    func `getSn`()  -> UInt64
    func `getPublicKey`()  -> String
    func `getNamespace`()  -> String
    func `getSchemaId`()  -> String
    func `getOwner`()  -> String
    func `getCreator`()  -> String
    func `getProperties`()  -> String
    func `getIsActive`()  -> Bool
    
}

public class UserGovernance: UserGovernanceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`subject`: UserSubject) throws {
        self.init(unsafeFromRawPointer: try
    
    rustCallWithError(FfiConverterTypeTapleError.self) {
    
    taple_ffi_b33d_UserGovernance_new(
        FfiConverterTypeUserSubject.lower(`subject`), $0)
})
    }

    deinit {
        try! rustCall { ffi_taple_ffi_b33d_UserGovernance_object_free(pointer, $0) }
    }

    

    
    public func `getMembers`() throws -> [String] {
        return try FfiConverterSequenceString.lift(
            try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_UserGovernance_get_members(self.pointer, $0
    )
}
        )
    }
    public func `getSchemas`() throws -> [Schema] {
        return try FfiConverterSequenceTypeSchema.lift(
            try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_UserGovernance_get_schemas(self.pointer, $0
    )
}
        )
    }
    public func `getPolicies`() throws -> [Policy] {
        return try FfiConverterSequenceTypePolicy.lift(
            try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_UserGovernance_get_policies(self.pointer, $0
    )
}
        )
    }
    public func `getRoles`() throws -> [Role] {
        return try FfiConverterSequenceTypeRole.lift(
            try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_UserGovernance_get_roles(self.pointer, $0
    )
}
        )
    }
    public func `refresh`() throws {
        try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_UserGovernance_refresh(self.pointer, $0
    )
}
    }
    public func `getSubjectId`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_UserGovernance_get_subject_id(self.pointer, $0
    )
}
        )
    }
    public func `getGovernanceId`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_UserGovernance_get_governance_id(self.pointer, $0
    )
}
        )
    }
    public func `getSn`()  -> UInt64 {
        return try! FfiConverterUInt64.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_UserGovernance_get_sn(self.pointer, $0
    )
}
        )
    }
    public func `getPublicKey`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_UserGovernance_get_public_key(self.pointer, $0
    )
}
        )
    }
    public func `getNamespace`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_UserGovernance_get_namespace(self.pointer, $0
    )
}
        )
    }
    public func `getSchemaId`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_UserGovernance_get_schema_id(self.pointer, $0
    )
}
        )
    }
    public func `getOwner`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_UserGovernance_get_owner(self.pointer, $0
    )
}
        )
    }
    public func `getCreator`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_UserGovernance_get_creator(self.pointer, $0
    )
}
        )
    }
    public func `getProperties`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_UserGovernance_get_properties(self.pointer, $0
    )
}
        )
    }
    public func `getIsActive`()  -> Bool {
        return try! FfiConverterBool.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_UserGovernance_get_is_active(self.pointer, $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeUserGovernance: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UserGovernance

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserGovernance {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UserGovernance, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UserGovernance {
        return UserGovernance(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UserGovernance) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol UserSubjectProtocol {
    func `endLifeCicle`() throws -> String
    func `newFactEvent`(`payload`: String) throws -> String
    func `refresh`() throws
    func `externalInvokation`(`event`: TapleSignedEventRequest) throws -> String
    func `toGovernance`()  -> UserGovernance?
    func `getSubjectId`()  -> String?
    func `getGovernanceId`()  -> String?
    func `getSn`()  -> UInt64?
    func `getPublicKey`()  -> String?
    func `getNamespace`()  -> String?
    func `getSchemaId`()  -> String?
    func `getOwner`()  -> String?
    func `getCreator`()  -> String?
    func `getProperties`()  -> String?
    func `getSubjectRequest`()  -> String?
    func `getIsActive`()  -> Bool?
    
}

public class UserSubject: UserSubjectProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_taple_ffi_b33d_UserSubject_object_free(pointer, $0) }
    }

    

    
    public func `endLifeCicle`() throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_UserSubject_end_life_cicle(self.pointer, $0
    )
}
        )
    }
    public func `newFactEvent`(`payload`: String) throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_UserSubject_new_fact_event(self.pointer, 
        FfiConverterString.lower(`payload`), $0
    )
}
        )
    }
    public func `refresh`() throws {
        try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_UserSubject_refresh(self.pointer, $0
    )
}
    }
    public func `externalInvokation`(`event`: TapleSignedEventRequest) throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeTapleError.self) {
    taple_ffi_b33d_UserSubject_external_invokation(self.pointer, 
        FfiConverterTypeTapleSignedEventRequest.lower(`event`), $0
    )
}
        )
    }
    public func `toGovernance`()  -> UserGovernance? {
        return try! FfiConverterOptionTypeUserGovernance.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_UserSubject_to_governance(self.pointer, $0
    )
}
        )
    }
    public func `getSubjectId`()  -> String? {
        return try! FfiConverterOptionString.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_UserSubject_get_subject_id(self.pointer, $0
    )
}
        )
    }
    public func `getGovernanceId`()  -> String? {
        return try! FfiConverterOptionString.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_UserSubject_get_governance_id(self.pointer, $0
    )
}
        )
    }
    public func `getSn`()  -> UInt64? {
        return try! FfiConverterOptionUInt64.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_UserSubject_get_sn(self.pointer, $0
    )
}
        )
    }
    public func `getPublicKey`()  -> String? {
        return try! FfiConverterOptionString.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_UserSubject_get_public_key(self.pointer, $0
    )
}
        )
    }
    public func `getNamespace`()  -> String? {
        return try! FfiConverterOptionString.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_UserSubject_get_namespace(self.pointer, $0
    )
}
        )
    }
    public func `getSchemaId`()  -> String? {
        return try! FfiConverterOptionString.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_UserSubject_get_schema_id(self.pointer, $0
    )
}
        )
    }
    public func `getOwner`()  -> String? {
        return try! FfiConverterOptionString.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_UserSubject_get_owner(self.pointer, $0
    )
}
        )
    }
    public func `getCreator`()  -> String? {
        return try! FfiConverterOptionString.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_UserSubject_get_creator(self.pointer, $0
    )
}
        )
    }
    public func `getProperties`()  -> String? {
        return try! FfiConverterOptionString.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_UserSubject_get_properties(self.pointer, $0
    )
}
        )
    }
    public func `getSubjectRequest`()  -> String? {
        return try! FfiConverterOptionString.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_UserSubject_get_subject_request(self.pointer, $0
    )
}
        )
    }
    public func `getIsActive`()  -> Bool? {
        return try! FfiConverterOptionBool.lift(
            try!
    rustCall() {
    
    taple_ffi_b33d_UserSubject_get_is_active(self.pointer, $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeUserSubject: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UserSubject

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserSubject {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UserSubject, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UserSubject {
        return UserSubject(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UserSubject) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public struct Policy {
    public var `id`: String
    public var `approve`: Validation
    public var `evaluate`: Validation
    public var `validate`: Validation

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: String, `approve`: Validation, `evaluate`: Validation, `validate`: Validation) {
        self.`id` = `id`
        self.`approve` = `approve`
        self.`evaluate` = `evaluate`
        self.`validate` = `validate`
    }
}


extension Policy: Equatable, Hashable {
    public static func ==(lhs: Policy, rhs: Policy) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`approve` != rhs.`approve` {
            return false
        }
        if lhs.`evaluate` != rhs.`evaluate` {
            return false
        }
        if lhs.`validate` != rhs.`validate` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`approve`)
        hasher.combine(`evaluate`)
        hasher.combine(`validate`)
    }
}


public struct FfiConverterTypePolicy: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Policy {
        return try Policy(
            `id`: FfiConverterString.read(from: &buf), 
            `approve`: FfiConverterTypeValidation.read(from: &buf), 
            `evaluate`: FfiConverterTypeValidation.read(from: &buf), 
            `validate`: FfiConverterTypeValidation.read(from: &buf)
        )
    }

    public static func write(_ value: Policy, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`id`, into: &buf)
        FfiConverterTypeValidation.write(value.`approve`, into: &buf)
        FfiConverterTypeValidation.write(value.`evaluate`, into: &buf)
        FfiConverterTypeValidation.write(value.`validate`, into: &buf)
    }
}


public func FfiConverterTypePolicy_lift(_ buf: RustBuffer) throws -> Policy {
    return try FfiConverterTypePolicy.lift(buf)
}

public func FfiConverterTypePolicy_lower(_ value: Policy) -> RustBuffer {
    return FfiConverterTypePolicy.lower(value)
}


public struct Role {
    public var `who`: Who
    public var `namespace`: String
    public var `role`: RoleEnum
    public var `schema`: SchemaEnum

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`who`: Who, `namespace`: String, `role`: RoleEnum, `schema`: SchemaEnum) {
        self.`who` = `who`
        self.`namespace` = `namespace`
        self.`role` = `role`
        self.`schema` = `schema`
    }
}


extension Role: Equatable, Hashable {
    public static func ==(lhs: Role, rhs: Role) -> Bool {
        if lhs.`who` != rhs.`who` {
            return false
        }
        if lhs.`namespace` != rhs.`namespace` {
            return false
        }
        if lhs.`role` != rhs.`role` {
            return false
        }
        if lhs.`schema` != rhs.`schema` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`who`)
        hasher.combine(`namespace`)
        hasher.combine(`role`)
        hasher.combine(`schema`)
    }
}


public struct FfiConverterTypeRole: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Role {
        return try Role(
            `who`: FfiConverterTypeWho.read(from: &buf), 
            `namespace`: FfiConverterString.read(from: &buf), 
            `role`: FfiConverterTypeRoleEnum.read(from: &buf), 
            `schema`: FfiConverterTypeSchemaEnum.read(from: &buf)
        )
    }

    public static func write(_ value: Role, into buf: inout [UInt8]) {
        FfiConverterTypeWho.write(value.`who`, into: &buf)
        FfiConverterString.write(value.`namespace`, into: &buf)
        FfiConverterTypeRoleEnum.write(value.`role`, into: &buf)
        FfiConverterTypeSchemaEnum.write(value.`schema`, into: &buf)
    }
}


public func FfiConverterTypeRole_lift(_ buf: RustBuffer) throws -> Role {
    return try FfiConverterTypeRole.lift(buf)
}

public func FfiConverterTypeRole_lower(_ value: Role) -> RustBuffer {
    return FfiConverterTypeRole.lower(value)
}


public struct Schema {
    public var `id`: String
    public var `schema`: String
    public var `initialValue`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: String, `schema`: String, `initialValue`: String) {
        self.`id` = `id`
        self.`schema` = `schema`
        self.`initialValue` = `initialValue`
    }
}


extension Schema: Equatable, Hashable {
    public static func ==(lhs: Schema, rhs: Schema) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`schema` != rhs.`schema` {
            return false
        }
        if lhs.`initialValue` != rhs.`initialValue` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`schema`)
        hasher.combine(`initialValue`)
    }
}


public struct FfiConverterTypeSchema: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Schema {
        return try Schema(
            `id`: FfiConverterString.read(from: &buf), 
            `schema`: FfiConverterString.read(from: &buf), 
            `initialValue`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Schema, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`id`, into: &buf)
        FfiConverterString.write(value.`schema`, into: &buf)
        FfiConverterString.write(value.`initialValue`, into: &buf)
    }
}


public func FfiConverterTypeSchema_lift(_ buf: RustBuffer) throws -> Schema {
    return try FfiConverterTypeSchema.lift(buf)
}

public func FfiConverterTypeSchema_lower(_ value: Schema) -> RustBuffer {
    return FfiConverterTypeSchema.lower(value)
}


public struct SubjectAndProviders {
    public var `subjectId`: String
    public var `providers`: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`subjectId`: String, `providers`: [String]) {
        self.`subjectId` = `subjectId`
        self.`providers` = `providers`
    }
}


extension SubjectAndProviders: Equatable, Hashable {
    public static func ==(lhs: SubjectAndProviders, rhs: SubjectAndProviders) -> Bool {
        if lhs.`subjectId` != rhs.`subjectId` {
            return false
        }
        if lhs.`providers` != rhs.`providers` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`subjectId`)
        hasher.combine(`providers`)
    }
}


public struct FfiConverterTypeSubjectAndProviders: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubjectAndProviders {
        return try SubjectAndProviders(
            `subjectId`: FfiConverterString.read(from: &buf), 
            `providers`: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: SubjectAndProviders, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`subjectId`, into: &buf)
        FfiConverterSequenceString.write(value.`providers`, into: &buf)
    }
}


public func FfiConverterTypeSubjectAndProviders_lift(_ buf: RustBuffer) throws -> SubjectAndProviders {
    return try FfiConverterTypeSubjectAndProviders.lift(buf)
}

public func FfiConverterTypeSubjectAndProviders_lower(_ value: SubjectAndProviders) -> RustBuffer {
    return FfiConverterTypeSubjectAndProviders.lower(value)
}


public struct TapleApprovalEntity {
    public var `id`: String
    public var `request`: TapleSignedApprovalRequest
    public var `response`: TapleSignedApprovalResponse?
    public var `state`: TapleApprovalState

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: String, `request`: TapleSignedApprovalRequest, `response`: TapleSignedApprovalResponse?, `state`: TapleApprovalState) {
        self.`id` = `id`
        self.`request` = `request`
        self.`response` = `response`
        self.`state` = `state`
    }
}


extension TapleApprovalEntity: Equatable, Hashable {
    public static func ==(lhs: TapleApprovalEntity, rhs: TapleApprovalEntity) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`request` != rhs.`request` {
            return false
        }
        if lhs.`response` != rhs.`response` {
            return false
        }
        if lhs.`state` != rhs.`state` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`request`)
        hasher.combine(`response`)
        hasher.combine(`state`)
    }
}


public struct FfiConverterTypeTapleApprovalEntity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapleApprovalEntity {
        return try TapleApprovalEntity(
            `id`: FfiConverterString.read(from: &buf), 
            `request`: FfiConverterTypeTapleSignedApprovalRequest.read(from: &buf), 
            `response`: FfiConverterOptionTypeTapleSignedApprovalResponse.read(from: &buf), 
            `state`: FfiConverterTypeTapleApprovalState.read(from: &buf)
        )
    }

    public static func write(_ value: TapleApprovalEntity, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`id`, into: &buf)
        FfiConverterTypeTapleSignedApprovalRequest.write(value.`request`, into: &buf)
        FfiConverterOptionTypeTapleSignedApprovalResponse.write(value.`response`, into: &buf)
        FfiConverterTypeTapleApprovalState.write(value.`state`, into: &buf)
    }
}


public func FfiConverterTypeTapleApprovalEntity_lift(_ buf: RustBuffer) throws -> TapleApprovalEntity {
    return try FfiConverterTypeTapleApprovalEntity.lift(buf)
}

public func FfiConverterTypeTapleApprovalEntity_lower(_ value: TapleApprovalEntity) -> RustBuffer {
    return FfiConverterTypeTapleApprovalEntity.lower(value)
}


public struct TapleApprovalRequest {
    public var `eventRequest`: TapleSignedEventRequest
    public var `sn`: UInt64
    public var `govVersion`: UInt64
    public var `patch`: String
    public var `stateHash`: String
    public var `hashPrevEvent`: String
    public var `govId`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`eventRequest`: TapleSignedEventRequest, `sn`: UInt64, `govVersion`: UInt64, `patch`: String, `stateHash`: String, `hashPrevEvent`: String, `govId`: String) {
        self.`eventRequest` = `eventRequest`
        self.`sn` = `sn`
        self.`govVersion` = `govVersion`
        self.`patch` = `patch`
        self.`stateHash` = `stateHash`
        self.`hashPrevEvent` = `hashPrevEvent`
        self.`govId` = `govId`
    }
}


extension TapleApprovalRequest: Equatable, Hashable {
    public static func ==(lhs: TapleApprovalRequest, rhs: TapleApprovalRequest) -> Bool {
        if lhs.`eventRequest` != rhs.`eventRequest` {
            return false
        }
        if lhs.`sn` != rhs.`sn` {
            return false
        }
        if lhs.`govVersion` != rhs.`govVersion` {
            return false
        }
        if lhs.`patch` != rhs.`patch` {
            return false
        }
        if lhs.`stateHash` != rhs.`stateHash` {
            return false
        }
        if lhs.`hashPrevEvent` != rhs.`hashPrevEvent` {
            return false
        }
        if lhs.`govId` != rhs.`govId` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`eventRequest`)
        hasher.combine(`sn`)
        hasher.combine(`govVersion`)
        hasher.combine(`patch`)
        hasher.combine(`stateHash`)
        hasher.combine(`hashPrevEvent`)
        hasher.combine(`govId`)
    }
}


public struct FfiConverterTypeTapleApprovalRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapleApprovalRequest {
        return try TapleApprovalRequest(
            `eventRequest`: FfiConverterTypeTapleSignedEventRequest.read(from: &buf), 
            `sn`: FfiConverterUInt64.read(from: &buf), 
            `govVersion`: FfiConverterUInt64.read(from: &buf), 
            `patch`: FfiConverterString.read(from: &buf), 
            `stateHash`: FfiConverterString.read(from: &buf), 
            `hashPrevEvent`: FfiConverterString.read(from: &buf), 
            `govId`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: TapleApprovalRequest, into buf: inout [UInt8]) {
        FfiConverterTypeTapleSignedEventRequest.write(value.`eventRequest`, into: &buf)
        FfiConverterUInt64.write(value.`sn`, into: &buf)
        FfiConverterUInt64.write(value.`govVersion`, into: &buf)
        FfiConverterString.write(value.`patch`, into: &buf)
        FfiConverterString.write(value.`stateHash`, into: &buf)
        FfiConverterString.write(value.`hashPrevEvent`, into: &buf)
        FfiConverterString.write(value.`govId`, into: &buf)
    }
}


public func FfiConverterTypeTapleApprovalRequest_lift(_ buf: RustBuffer) throws -> TapleApprovalRequest {
    return try FfiConverterTypeTapleApprovalRequest.lift(buf)
}

public func FfiConverterTypeTapleApprovalRequest_lower(_ value: TapleApprovalRequest) -> RustBuffer {
    return FfiConverterTypeTapleApprovalRequest.lower(value)
}


public struct TapleApprovalResponse {
    public var `apprReqHash`: String
    public var `approved`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`apprReqHash`: String, `approved`: Bool) {
        self.`apprReqHash` = `apprReqHash`
        self.`approved` = `approved`
    }
}


extension TapleApprovalResponse: Equatable, Hashable {
    public static func ==(lhs: TapleApprovalResponse, rhs: TapleApprovalResponse) -> Bool {
        if lhs.`apprReqHash` != rhs.`apprReqHash` {
            return false
        }
        if lhs.`approved` != rhs.`approved` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`apprReqHash`)
        hasher.combine(`approved`)
    }
}


public struct FfiConverterTypeTapleApprovalResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapleApprovalResponse {
        return try TapleApprovalResponse(
            `apprReqHash`: FfiConverterString.read(from: &buf), 
            `approved`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: TapleApprovalResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`apprReqHash`, into: &buf)
        FfiConverterBool.write(value.`approved`, into: &buf)
    }
}


public func FfiConverterTypeTapleApprovalResponse_lift(_ buf: RustBuffer) throws -> TapleApprovalResponse {
    return try FfiConverterTypeTapleApprovalResponse.lift(buf)
}

public func FfiConverterTypeTapleApprovalResponse_lower(_ value: TapleApprovalResponse) -> RustBuffer {
    return FfiConverterTypeTapleApprovalResponse.lower(value)
}


public struct TapleEvent {
    public var `subjectId`: String
    public var `eventRequest`: TapleSignedEventRequest
    public var `sn`: UInt64
    public var `govVersion`: UInt64
    public var `patch`: String
    public var `stateHash`: String
    public var `evalSuccess`: Bool
    public var `apprRequired`: Bool
    public var `approved`: Bool
    public var `hashPrevEvent`: String
    public var `evaluators`: [String: TapleSignature]
    public var `approvers`: [String: TapleSignature]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`subjectId`: String, `eventRequest`: TapleSignedEventRequest, `sn`: UInt64, `govVersion`: UInt64, `patch`: String, `stateHash`: String, `evalSuccess`: Bool, `apprRequired`: Bool, `approved`: Bool, `hashPrevEvent`: String, `evaluators`: [String: TapleSignature], `approvers`: [String: TapleSignature]) {
        self.`subjectId` = `subjectId`
        self.`eventRequest` = `eventRequest`
        self.`sn` = `sn`
        self.`govVersion` = `govVersion`
        self.`patch` = `patch`
        self.`stateHash` = `stateHash`
        self.`evalSuccess` = `evalSuccess`
        self.`apprRequired` = `apprRequired`
        self.`approved` = `approved`
        self.`hashPrevEvent` = `hashPrevEvent`
        self.`evaluators` = `evaluators`
        self.`approvers` = `approvers`
    }
}


extension TapleEvent: Equatable, Hashable {
    public static func ==(lhs: TapleEvent, rhs: TapleEvent) -> Bool {
        if lhs.`subjectId` != rhs.`subjectId` {
            return false
        }
        if lhs.`eventRequest` != rhs.`eventRequest` {
            return false
        }
        if lhs.`sn` != rhs.`sn` {
            return false
        }
        if lhs.`govVersion` != rhs.`govVersion` {
            return false
        }
        if lhs.`patch` != rhs.`patch` {
            return false
        }
        if lhs.`stateHash` != rhs.`stateHash` {
            return false
        }
        if lhs.`evalSuccess` != rhs.`evalSuccess` {
            return false
        }
        if lhs.`apprRequired` != rhs.`apprRequired` {
            return false
        }
        if lhs.`approved` != rhs.`approved` {
            return false
        }
        if lhs.`hashPrevEvent` != rhs.`hashPrevEvent` {
            return false
        }
        if lhs.`evaluators` != rhs.`evaluators` {
            return false
        }
        if lhs.`approvers` != rhs.`approvers` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`subjectId`)
        hasher.combine(`eventRequest`)
        hasher.combine(`sn`)
        hasher.combine(`govVersion`)
        hasher.combine(`patch`)
        hasher.combine(`stateHash`)
        hasher.combine(`evalSuccess`)
        hasher.combine(`apprRequired`)
        hasher.combine(`approved`)
        hasher.combine(`hashPrevEvent`)
        hasher.combine(`evaluators`)
        hasher.combine(`approvers`)
    }
}


public struct FfiConverterTypeTapleEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapleEvent {
        return try TapleEvent(
            `subjectId`: FfiConverterString.read(from: &buf), 
            `eventRequest`: FfiConverterTypeTapleSignedEventRequest.read(from: &buf), 
            `sn`: FfiConverterUInt64.read(from: &buf), 
            `govVersion`: FfiConverterUInt64.read(from: &buf), 
            `patch`: FfiConverterString.read(from: &buf), 
            `stateHash`: FfiConverterString.read(from: &buf), 
            `evalSuccess`: FfiConverterBool.read(from: &buf), 
            `apprRequired`: FfiConverterBool.read(from: &buf), 
            `approved`: FfiConverterBool.read(from: &buf), 
            `hashPrevEvent`: FfiConverterString.read(from: &buf), 
            `evaluators`: FfiConverterDictionaryStringTypeTapleSignature.read(from: &buf), 
            `approvers`: FfiConverterDictionaryStringTypeTapleSignature.read(from: &buf)
        )
    }

    public static func write(_ value: TapleEvent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`subjectId`, into: &buf)
        FfiConverterTypeTapleSignedEventRequest.write(value.`eventRequest`, into: &buf)
        FfiConverterUInt64.write(value.`sn`, into: &buf)
        FfiConverterUInt64.write(value.`govVersion`, into: &buf)
        FfiConverterString.write(value.`patch`, into: &buf)
        FfiConverterString.write(value.`stateHash`, into: &buf)
        FfiConverterBool.write(value.`evalSuccess`, into: &buf)
        FfiConverterBool.write(value.`apprRequired`, into: &buf)
        FfiConverterBool.write(value.`approved`, into: &buf)
        FfiConverterString.write(value.`hashPrevEvent`, into: &buf)
        FfiConverterDictionaryStringTypeTapleSignature.write(value.`evaluators`, into: &buf)
        FfiConverterDictionaryStringTypeTapleSignature.write(value.`approvers`, into: &buf)
    }
}


public func FfiConverterTypeTapleEvent_lift(_ buf: RustBuffer) throws -> TapleEvent {
    return try FfiConverterTypeTapleEvent.lift(buf)
}

public func FfiConverterTypeTapleEvent_lower(_ value: TapleEvent) -> RustBuffer {
    return FfiConverterTypeTapleEvent.lower(value)
}


public struct TapleRequest {
    public var `id`: String
    public var `subjectId`: String?
    public var `sn`: UInt64
    public var `eventRequest`: TapleSignedEventRequest
    public var `state`: TapleRequestState
    public var `success`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: String, `subjectId`: String?, `sn`: UInt64, `eventRequest`: TapleSignedEventRequest, `state`: TapleRequestState, `success`: Bool) {
        self.`id` = `id`
        self.`subjectId` = `subjectId`
        self.`sn` = `sn`
        self.`eventRequest` = `eventRequest`
        self.`state` = `state`
        self.`success` = `success`
    }
}


extension TapleRequest: Equatable, Hashable {
    public static func ==(lhs: TapleRequest, rhs: TapleRequest) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`subjectId` != rhs.`subjectId` {
            return false
        }
        if lhs.`sn` != rhs.`sn` {
            return false
        }
        if lhs.`eventRequest` != rhs.`eventRequest` {
            return false
        }
        if lhs.`state` != rhs.`state` {
            return false
        }
        if lhs.`success` != rhs.`success` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`subjectId`)
        hasher.combine(`sn`)
        hasher.combine(`eventRequest`)
        hasher.combine(`state`)
        hasher.combine(`success`)
    }
}


public struct FfiConverterTypeTapleRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapleRequest {
        return try TapleRequest(
            `id`: FfiConverterString.read(from: &buf), 
            `subjectId`: FfiConverterOptionString.read(from: &buf), 
            `sn`: FfiConverterUInt64.read(from: &buf), 
            `eventRequest`: FfiConverterTypeTapleSignedEventRequest.read(from: &buf), 
            `state`: FfiConverterTypeTapleRequestState.read(from: &buf), 
            `success`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: TapleRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`id`, into: &buf)
        FfiConverterOptionString.write(value.`subjectId`, into: &buf)
        FfiConverterUInt64.write(value.`sn`, into: &buf)
        FfiConverterTypeTapleSignedEventRequest.write(value.`eventRequest`, into: &buf)
        FfiConverterTypeTapleRequestState.write(value.`state`, into: &buf)
        FfiConverterBool.write(value.`success`, into: &buf)
    }
}


public func FfiConverterTypeTapleRequest_lift(_ buf: RustBuffer) throws -> TapleRequest {
    return try FfiConverterTypeTapleRequest.lift(buf)
}

public func FfiConverterTypeTapleRequest_lower(_ value: TapleRequest) -> RustBuffer {
    return FfiConverterTypeTapleRequest.lower(value)
}


public struct TapleSettings {
    public var `listenAddr`: [String]
    public var `keyDerivator`: TapleKeyDerivator
    public var `privateKey`: [UInt8]
    public var `knownNodes`: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`listenAddr`: [String], `keyDerivator`: TapleKeyDerivator, `privateKey`: [UInt8], `knownNodes`: [String]) {
        self.`listenAddr` = `listenAddr`
        self.`keyDerivator` = `keyDerivator`
        self.`privateKey` = `privateKey`
        self.`knownNodes` = `knownNodes`
    }
}


extension TapleSettings: Equatable, Hashable {
    public static func ==(lhs: TapleSettings, rhs: TapleSettings) -> Bool {
        if lhs.`listenAddr` != rhs.`listenAddr` {
            return false
        }
        if lhs.`keyDerivator` != rhs.`keyDerivator` {
            return false
        }
        if lhs.`privateKey` != rhs.`privateKey` {
            return false
        }
        if lhs.`knownNodes` != rhs.`knownNodes` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`listenAddr`)
        hasher.combine(`keyDerivator`)
        hasher.combine(`privateKey`)
        hasher.combine(`knownNodes`)
    }
}


public struct FfiConverterTypeTapleSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapleSettings {
        return try TapleSettings(
            `listenAddr`: FfiConverterSequenceString.read(from: &buf), 
            `keyDerivator`: FfiConverterTypeTapleKeyDerivator.read(from: &buf), 
            `privateKey`: FfiConverterSequenceUInt8.read(from: &buf), 
            `knownNodes`: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: TapleSettings, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.`listenAddr`, into: &buf)
        FfiConverterTypeTapleKeyDerivator.write(value.`keyDerivator`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`privateKey`, into: &buf)
        FfiConverterSequenceString.write(value.`knownNodes`, into: &buf)
    }
}


public func FfiConverterTypeTapleSettings_lift(_ buf: RustBuffer) throws -> TapleSettings {
    return try FfiConverterTypeTapleSettings.lift(buf)
}

public func FfiConverterTypeTapleSettings_lower(_ value: TapleSettings) -> RustBuffer {
    return FfiConverterTypeTapleSettings.lower(value)
}


public struct TapleSignature {
    public var `signer`: String
    public var `timestamp`: UInt64
    public var `value`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`signer`: String, `timestamp`: UInt64, `value`: String) {
        self.`signer` = `signer`
        self.`timestamp` = `timestamp`
        self.`value` = `value`
    }
}


extension TapleSignature: Equatable, Hashable {
    public static func ==(lhs: TapleSignature, rhs: TapleSignature) -> Bool {
        if lhs.`signer` != rhs.`signer` {
            return false
        }
        if lhs.`timestamp` != rhs.`timestamp` {
            return false
        }
        if lhs.`value` != rhs.`value` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`signer`)
        hasher.combine(`timestamp`)
        hasher.combine(`value`)
    }
}


public struct FfiConverterTypeTapleSignature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapleSignature {
        return try TapleSignature(
            `signer`: FfiConverterString.read(from: &buf), 
            `timestamp`: FfiConverterUInt64.read(from: &buf), 
            `value`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: TapleSignature, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`signer`, into: &buf)
        FfiConverterUInt64.write(value.`timestamp`, into: &buf)
        FfiConverterString.write(value.`value`, into: &buf)
    }
}


public func FfiConverterTypeTapleSignature_lift(_ buf: RustBuffer) throws -> TapleSignature {
    return try FfiConverterTypeTapleSignature.lift(buf)
}

public func FfiConverterTypeTapleSignature_lower(_ value: TapleSignature) -> RustBuffer {
    return FfiConverterTypeTapleSignature.lower(value)
}


public struct TapleSignedApprovalRequest {
    public var `content`: TapleApprovalRequest
    public var `signature`: TapleSignature

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`content`: TapleApprovalRequest, `signature`: TapleSignature) {
        self.`content` = `content`
        self.`signature` = `signature`
    }
}


extension TapleSignedApprovalRequest: Equatable, Hashable {
    public static func ==(lhs: TapleSignedApprovalRequest, rhs: TapleSignedApprovalRequest) -> Bool {
        if lhs.`content` != rhs.`content` {
            return false
        }
        if lhs.`signature` != rhs.`signature` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`content`)
        hasher.combine(`signature`)
    }
}


public struct FfiConverterTypeTapleSignedApprovalRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapleSignedApprovalRequest {
        return try TapleSignedApprovalRequest(
            `content`: FfiConverterTypeTapleApprovalRequest.read(from: &buf), 
            `signature`: FfiConverterTypeTapleSignature.read(from: &buf)
        )
    }

    public static func write(_ value: TapleSignedApprovalRequest, into buf: inout [UInt8]) {
        FfiConverterTypeTapleApprovalRequest.write(value.`content`, into: &buf)
        FfiConverterTypeTapleSignature.write(value.`signature`, into: &buf)
    }
}


public func FfiConverterTypeTapleSignedApprovalRequest_lift(_ buf: RustBuffer) throws -> TapleSignedApprovalRequest {
    return try FfiConverterTypeTapleSignedApprovalRequest.lift(buf)
}

public func FfiConverterTypeTapleSignedApprovalRequest_lower(_ value: TapleSignedApprovalRequest) -> RustBuffer {
    return FfiConverterTypeTapleSignedApprovalRequest.lower(value)
}


public struct TapleSignedApprovalResponse {
    public var `content`: TapleApprovalResponse
    public var `signature`: TapleSignature

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`content`: TapleApprovalResponse, `signature`: TapleSignature) {
        self.`content` = `content`
        self.`signature` = `signature`
    }
}


extension TapleSignedApprovalResponse: Equatable, Hashable {
    public static func ==(lhs: TapleSignedApprovalResponse, rhs: TapleSignedApprovalResponse) -> Bool {
        if lhs.`content` != rhs.`content` {
            return false
        }
        if lhs.`signature` != rhs.`signature` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`content`)
        hasher.combine(`signature`)
    }
}


public struct FfiConverterTypeTapleSignedApprovalResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapleSignedApprovalResponse {
        return try TapleSignedApprovalResponse(
            `content`: FfiConverterTypeTapleApprovalResponse.read(from: &buf), 
            `signature`: FfiConverterTypeTapleSignature.read(from: &buf)
        )
    }

    public static func write(_ value: TapleSignedApprovalResponse, into buf: inout [UInt8]) {
        FfiConverterTypeTapleApprovalResponse.write(value.`content`, into: &buf)
        FfiConverterTypeTapleSignature.write(value.`signature`, into: &buf)
    }
}


public func FfiConverterTypeTapleSignedApprovalResponse_lift(_ buf: RustBuffer) throws -> TapleSignedApprovalResponse {
    return try FfiConverterTypeTapleSignedApprovalResponse.lift(buf)
}

public func FfiConverterTypeTapleSignedApprovalResponse_lower(_ value: TapleSignedApprovalResponse) -> RustBuffer {
    return FfiConverterTypeTapleSignedApprovalResponse.lower(value)
}


public struct TapleSignedEvent {
    public var `content`: TapleEvent
    public var `signature`: TapleSignature

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`content`: TapleEvent, `signature`: TapleSignature) {
        self.`content` = `content`
        self.`signature` = `signature`
    }
}


extension TapleSignedEvent: Equatable, Hashable {
    public static func ==(lhs: TapleSignedEvent, rhs: TapleSignedEvent) -> Bool {
        if lhs.`content` != rhs.`content` {
            return false
        }
        if lhs.`signature` != rhs.`signature` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`content`)
        hasher.combine(`signature`)
    }
}


public struct FfiConverterTypeTapleSignedEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapleSignedEvent {
        return try TapleSignedEvent(
            `content`: FfiConverterTypeTapleEvent.read(from: &buf), 
            `signature`: FfiConverterTypeTapleSignature.read(from: &buf)
        )
    }

    public static func write(_ value: TapleSignedEvent, into buf: inout [UInt8]) {
        FfiConverterTypeTapleEvent.write(value.`content`, into: &buf)
        FfiConverterTypeTapleSignature.write(value.`signature`, into: &buf)
    }
}


public func FfiConverterTypeTapleSignedEvent_lift(_ buf: RustBuffer) throws -> TapleSignedEvent {
    return try FfiConverterTypeTapleSignedEvent.lift(buf)
}

public func FfiConverterTypeTapleSignedEvent_lower(_ value: TapleSignedEvent) -> RustBuffer {
    return FfiConverterTypeTapleSignedEvent.lower(value)
}


public struct TapleSignedEventRequest {
    public var `content`: EventRequestType
    public var `signature`: TapleSignature

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`content`: EventRequestType, `signature`: TapleSignature) {
        self.`content` = `content`
        self.`signature` = `signature`
    }
}


extension TapleSignedEventRequest: Equatable, Hashable {
    public static func ==(lhs: TapleSignedEventRequest, rhs: TapleSignedEventRequest) -> Bool {
        if lhs.`content` != rhs.`content` {
            return false
        }
        if lhs.`signature` != rhs.`signature` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`content`)
        hasher.combine(`signature`)
    }
}


public struct FfiConverterTypeTapleSignedEventRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapleSignedEventRequest {
        return try TapleSignedEventRequest(
            `content`: FfiConverterTypeEventRequestType.read(from: &buf), 
            `signature`: FfiConverterTypeTapleSignature.read(from: &buf)
        )
    }

    public static func write(_ value: TapleSignedEventRequest, into buf: inout [UInt8]) {
        FfiConverterTypeEventRequestType.write(value.`content`, into: &buf)
        FfiConverterTypeTapleSignature.write(value.`signature`, into: &buf)
    }
}


public func FfiConverterTypeTapleSignedEventRequest_lift(_ buf: RustBuffer) throws -> TapleSignedEventRequest {
    return try FfiConverterTypeTapleSignedEventRequest.lift(buf)
}

public func FfiConverterTypeTapleSignedEventRequest_lower(_ value: TapleSignedEventRequest) -> RustBuffer {
    return FfiConverterTypeTapleSignedEventRequest.lower(value)
}


public struct Tuple {
    public var `key`: String
    public var `value`: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`key`: String, `value`: [UInt8]) {
        self.`key` = `key`
        self.`value` = `value`
    }
}


extension Tuple: Equatable, Hashable {
    public static func ==(lhs: Tuple, rhs: Tuple) -> Bool {
        if lhs.`key` != rhs.`key` {
            return false
        }
        if lhs.`value` != rhs.`value` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`key`)
        hasher.combine(`value`)
    }
}


public struct FfiConverterTypeTuple: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Tuple {
        return try Tuple(
            `key`: FfiConverterString.read(from: &buf), 
            `value`: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: Tuple, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`key`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`value`, into: &buf)
    }
}


public func FfiConverterTypeTuple_lift(_ buf: RustBuffer) throws -> Tuple {
    return try FfiConverterTypeTuple.lift(buf)
}

public func FfiConverterTypeTuple_lower(_ value: Tuple) -> RustBuffer {
    return FfiConverterTypeTuple.lower(value)
}


public struct Validation {
    public var `quorum`: Quorum

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`quorum`: Quorum) {
        self.`quorum` = `quorum`
    }
}


extension Validation: Equatable, Hashable {
    public static func ==(lhs: Validation, rhs: Validation) -> Bool {
        if lhs.`quorum` != rhs.`quorum` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`quorum`)
    }
}


public struct FfiConverterTypeValidation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Validation {
        return try Validation(
            `quorum`: FfiConverterTypeQuorum.read(from: &buf)
        )
    }

    public static func write(_ value: Validation, into buf: inout [UInt8]) {
        FfiConverterTypeQuorum.write(value.`quorum`, into: &buf)
    }
}


public func FfiConverterTypeValidation_lift(_ buf: RustBuffer) throws -> Validation {
    return try FfiConverterTypeValidation.lift(buf)
}

public func FfiConverterTypeValidation_lower(_ value: Validation) -> RustBuffer {
    return FfiConverterTypeValidation.lower(value)
}


public struct ValidationProof {
    public var `subjectId`: String
    public var `schemaId`: String
    public var `namespace`: String
    public var `name`: String
    public var `subjectPublicKey`: String
    public var `governanceId`: String
    public var `genesisGovernanceVersion`: UInt64
    public var `sn`: UInt64
    public var `prevEventHash`: String
    public var `eventHash`: String
    public var `governanceVersion`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`subjectId`: String, `schemaId`: String, `namespace`: String, `name`: String, `subjectPublicKey`: String, `governanceId`: String, `genesisGovernanceVersion`: UInt64, `sn`: UInt64, `prevEventHash`: String, `eventHash`: String, `governanceVersion`: UInt64) {
        self.`subjectId` = `subjectId`
        self.`schemaId` = `schemaId`
        self.`namespace` = `namespace`
        self.`name` = `name`
        self.`subjectPublicKey` = `subjectPublicKey`
        self.`governanceId` = `governanceId`
        self.`genesisGovernanceVersion` = `genesisGovernanceVersion`
        self.`sn` = `sn`
        self.`prevEventHash` = `prevEventHash`
        self.`eventHash` = `eventHash`
        self.`governanceVersion` = `governanceVersion`
    }
}


extension ValidationProof: Equatable, Hashable {
    public static func ==(lhs: ValidationProof, rhs: ValidationProof) -> Bool {
        if lhs.`subjectId` != rhs.`subjectId` {
            return false
        }
        if lhs.`schemaId` != rhs.`schemaId` {
            return false
        }
        if lhs.`namespace` != rhs.`namespace` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`subjectPublicKey` != rhs.`subjectPublicKey` {
            return false
        }
        if lhs.`governanceId` != rhs.`governanceId` {
            return false
        }
        if lhs.`genesisGovernanceVersion` != rhs.`genesisGovernanceVersion` {
            return false
        }
        if lhs.`sn` != rhs.`sn` {
            return false
        }
        if lhs.`prevEventHash` != rhs.`prevEventHash` {
            return false
        }
        if lhs.`eventHash` != rhs.`eventHash` {
            return false
        }
        if lhs.`governanceVersion` != rhs.`governanceVersion` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`subjectId`)
        hasher.combine(`schemaId`)
        hasher.combine(`namespace`)
        hasher.combine(`name`)
        hasher.combine(`subjectPublicKey`)
        hasher.combine(`governanceId`)
        hasher.combine(`genesisGovernanceVersion`)
        hasher.combine(`sn`)
        hasher.combine(`prevEventHash`)
        hasher.combine(`eventHash`)
        hasher.combine(`governanceVersion`)
    }
}


public struct FfiConverterTypeValidationProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidationProof {
        return try ValidationProof(
            `subjectId`: FfiConverterString.read(from: &buf), 
            `schemaId`: FfiConverterString.read(from: &buf), 
            `namespace`: FfiConverterString.read(from: &buf), 
            `name`: FfiConverterString.read(from: &buf), 
            `subjectPublicKey`: FfiConverterString.read(from: &buf), 
            `governanceId`: FfiConverterString.read(from: &buf), 
            `genesisGovernanceVersion`: FfiConverterUInt64.read(from: &buf), 
            `sn`: FfiConverterUInt64.read(from: &buf), 
            `prevEventHash`: FfiConverterString.read(from: &buf), 
            `eventHash`: FfiConverterString.read(from: &buf), 
            `governanceVersion`: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ValidationProof, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`subjectId`, into: &buf)
        FfiConverterString.write(value.`schemaId`, into: &buf)
        FfiConverterString.write(value.`namespace`, into: &buf)
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterString.write(value.`subjectPublicKey`, into: &buf)
        FfiConverterString.write(value.`governanceId`, into: &buf)
        FfiConverterUInt64.write(value.`genesisGovernanceVersion`, into: &buf)
        FfiConverterUInt64.write(value.`sn`, into: &buf)
        FfiConverterString.write(value.`prevEventHash`, into: &buf)
        FfiConverterString.write(value.`eventHash`, into: &buf)
        FfiConverterUInt64.write(value.`governanceVersion`, into: &buf)
    }
}


public func FfiConverterTypeValidationProof_lift(_ buf: RustBuffer) throws -> ValidationProof {
    return try FfiConverterTypeValidationProof.lift(buf)
}

public func FfiConverterTypeValidationProof_lower(_ value: ValidationProof) -> RustBuffer {
    return FfiConverterTypeValidationProof.lower(value)
}


public struct ValidationProofAndSignatures {
    public var `validationProof`: ValidationProof
    public var `signatures`: [TapleSignature]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`validationProof`: ValidationProof, `signatures`: [TapleSignature]) {
        self.`validationProof` = `validationProof`
        self.`signatures` = `signatures`
    }
}


extension ValidationProofAndSignatures: Equatable, Hashable {
    public static func ==(lhs: ValidationProofAndSignatures, rhs: ValidationProofAndSignatures) -> Bool {
        if lhs.`validationProof` != rhs.`validationProof` {
            return false
        }
        if lhs.`signatures` != rhs.`signatures` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`validationProof`)
        hasher.combine(`signatures`)
    }
}


public struct FfiConverterTypeValidationProofAndSignatures: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidationProofAndSignatures {
        return try ValidationProofAndSignatures(
            `validationProof`: FfiConverterTypeValidationProof.read(from: &buf), 
            `signatures`: FfiConverterSequenceTypeTapleSignature.read(from: &buf)
        )
    }

    public static func write(_ value: ValidationProofAndSignatures, into buf: inout [UInt8]) {
        FfiConverterTypeValidationProof.write(value.`validationProof`, into: &buf)
        FfiConverterSequenceTypeTapleSignature.write(value.`signatures`, into: &buf)
    }
}


public func FfiConverterTypeValidationProofAndSignatures_lift(_ buf: RustBuffer) throws -> ValidationProofAndSignatures {
    return try FfiConverterTypeValidationProofAndSignatures.lift(buf)
}

public func FfiConverterTypeValidationProofAndSignatures_lower(_ value: ValidationProofAndSignatures) -> RustBuffer {
    return FfiConverterTypeValidationProofAndSignatures.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EventRequestType {
    
    case `create`(`governanceId`: String, `schemaId`: String, `namespace`: String, `name`: String, `publicKey`: String)
    case `fact`(`subjectId`: String, `payload`: String)
    case `transfer`(`subjectId`: String, `publicKey`: String)
    case `eol`(`subjectId`: String)
}

public struct FfiConverterTypeEventRequestType: FfiConverterRustBuffer {
    typealias SwiftType = EventRequestType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventRequestType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`create`(
            `governanceId`: try FfiConverterString.read(from: &buf), 
            `schemaId`: try FfiConverterString.read(from: &buf), 
            `namespace`: try FfiConverterString.read(from: &buf), 
            `name`: try FfiConverterString.read(from: &buf), 
            `publicKey`: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .`fact`(
            `subjectId`: try FfiConverterString.read(from: &buf), 
            `payload`: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .`transfer`(
            `subjectId`: try FfiConverterString.read(from: &buf), 
            `publicKey`: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .`eol`(
            `subjectId`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EventRequestType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`create`(`governanceId`,`schemaId`,`namespace`,`name`,`publicKey`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`governanceId`, into: &buf)
            FfiConverterString.write(`schemaId`, into: &buf)
            FfiConverterString.write(`namespace`, into: &buf)
            FfiConverterString.write(`name`, into: &buf)
            FfiConverterString.write(`publicKey`, into: &buf)
            
        
        case let .`fact`(`subjectId`,`payload`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`subjectId`, into: &buf)
            FfiConverterString.write(`payload`, into: &buf)
            
        
        case let .`transfer`(`subjectId`,`publicKey`):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(`subjectId`, into: &buf)
            FfiConverterString.write(`publicKey`, into: &buf)
            
        
        case let .`eol`(`subjectId`):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(`subjectId`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeEventRequestType_lift(_ buf: RustBuffer) throws -> EventRequestType {
    return try FfiConverterTypeEventRequestType.lift(buf)
}

public func FfiConverterTypeEventRequestType_lower(_ value: EventRequestType) -> RustBuffer {
    return FfiConverterTypeEventRequestType.lower(value)
}


extension EventRequestType: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Quorum {
    
    case `majority`
    case `fixed`(`value`: UInt64)
    case `percentage`(`value`: Double)
}

public struct FfiConverterTypeQuorum: FfiConverterRustBuffer {
    typealias SwiftType = Quorum

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Quorum {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`majority`
        
        case 2: return .`fixed`(
            `value`: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 3: return .`percentage`(
            `value`: try FfiConverterDouble.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Quorum, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`majority`:
            writeInt(&buf, Int32(1))
        
        
        case let .`fixed`(`value`):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(`value`, into: &buf)
            
        
        case let .`percentage`(`value`):
            writeInt(&buf, Int32(3))
            FfiConverterDouble.write(`value`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeQuorum_lift(_ buf: RustBuffer) throws -> Quorum {
    return try FfiConverterTypeQuorum.lift(buf)
}

public func FfiConverterTypeQuorum_lower(_ value: Quorum) -> RustBuffer {
    return FfiConverterTypeQuorum.lower(value)
}


extension Quorum: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RoleEnum {
    
    case `validator`
    case `creator`
    case `issuer`
    case `witness`
    case `approver`
    case `evaluator`
}

public struct FfiConverterTypeRoleEnum: FfiConverterRustBuffer {
    typealias SwiftType = RoleEnum

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoleEnum {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`validator`
        
        case 2: return .`creator`
        
        case 3: return .`issuer`
        
        case 4: return .`witness`
        
        case 5: return .`approver`
        
        case 6: return .`evaluator`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoleEnum, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`validator`:
            writeInt(&buf, Int32(1))
        
        
        case .`creator`:
            writeInt(&buf, Int32(2))
        
        
        case .`issuer`:
            writeInt(&buf, Int32(3))
        
        
        case .`witness`:
            writeInt(&buf, Int32(4))
        
        
        case .`approver`:
            writeInt(&buf, Int32(5))
        
        
        case .`evaluator`:
            writeInt(&buf, Int32(6))
        
        }
    }
}


public func FfiConverterTypeRoleEnum_lift(_ buf: RustBuffer) throws -> RoleEnum {
    return try FfiConverterTypeRoleEnum.lift(buf)
}

public func FfiConverterTypeRoleEnum_lower(_ value: RoleEnum) -> RustBuffer {
    return FfiConverterTypeRoleEnum.lower(value)
}


extension RoleEnum: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SchemaEnum {
    
    case `id`(`id`: String)
    case `notGovernance`
    case `all`
}

public struct FfiConverterTypeSchemaEnum: FfiConverterRustBuffer {
    typealias SwiftType = SchemaEnum

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SchemaEnum {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`id`(
            `id`: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .`notGovernance`
        
        case 3: return .`all`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SchemaEnum, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`id`(`id`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`id`, into: &buf)
            
        
        case .`notGovernance`:
            writeInt(&buf, Int32(2))
        
        
        case .`all`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeSchemaEnum_lift(_ buf: RustBuffer) throws -> SchemaEnum {
    return try FfiConverterTypeSchemaEnum.lift(buf)
}

public func FfiConverterTypeSchemaEnum_lower(_ value: SchemaEnum) -> RustBuffer {
    return FfiConverterTypeSchemaEnum.lower(value)
}


extension SchemaEnum: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TapleApprovalState {
    
    case `pending`
    case `respondedAccepted`
    case `respondedRejected`
    case `obsolete`
}

public struct FfiConverterTypeTapleApprovalState: FfiConverterRustBuffer {
    typealias SwiftType = TapleApprovalState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapleApprovalState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`pending`
        
        case 2: return .`respondedAccepted`
        
        case 3: return .`respondedRejected`
        
        case 4: return .`obsolete`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TapleApprovalState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`pending`:
            writeInt(&buf, Int32(1))
        
        
        case .`respondedAccepted`:
            writeInt(&buf, Int32(2))
        
        
        case .`respondedRejected`:
            writeInt(&buf, Int32(3))
        
        
        case .`obsolete`:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeTapleApprovalState_lift(_ buf: RustBuffer) throws -> TapleApprovalState {
    return try FfiConverterTypeTapleApprovalState.lift(buf)
}

public func FfiConverterTypeTapleApprovalState_lower(_ value: TapleApprovalState) -> RustBuffer {
    return FfiConverterTypeTapleApprovalState.lower(value)
}


extension TapleApprovalState: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TapleKeyDerivator {
    
    case `ed25519`
    case `secp256k1`
}

public struct FfiConverterTypeTapleKeyDerivator: FfiConverterRustBuffer {
    typealias SwiftType = TapleKeyDerivator

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapleKeyDerivator {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`ed25519`
        
        case 2: return .`secp256k1`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TapleKeyDerivator, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`ed25519`:
            writeInt(&buf, Int32(1))
        
        
        case .`secp256k1`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeTapleKeyDerivator_lift(_ buf: RustBuffer) throws -> TapleKeyDerivator {
    return try FfiConverterTypeTapleKeyDerivator.lift(buf)
}

public func FfiConverterTypeTapleKeyDerivator_lower(_ value: TapleKeyDerivator) -> RustBuffer {
    return FfiConverterTypeTapleKeyDerivator.lower(value)
}


extension TapleKeyDerivator: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TapleNotification {
    
    case `newSubject`(`subjectId`: String)
    case `newEvent`(`sn`: UInt64, `subjectId`: String)
    case `stateUpdated`(`sn`: UInt64, `subjectId`: String)
    case `approvalReceived`(`id`: String, `subjectId`: String, `sn`: UInt64)
    case `obsoletedApproval`(`id`: String, `subjectId`: String, `sn`: UInt64)
    case `unrecoverableError`(`error`: String)
}

public struct FfiConverterTypeTapleNotification: FfiConverterRustBuffer {
    typealias SwiftType = TapleNotification

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapleNotification {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`newSubject`(
            `subjectId`: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .`newEvent`(
            `sn`: try FfiConverterUInt64.read(from: &buf), 
            `subjectId`: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .`stateUpdated`(
            `sn`: try FfiConverterUInt64.read(from: &buf), 
            `subjectId`: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .`approvalReceived`(
            `id`: try FfiConverterString.read(from: &buf), 
            `subjectId`: try FfiConverterString.read(from: &buf), 
            `sn`: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 5: return .`obsoletedApproval`(
            `id`: try FfiConverterString.read(from: &buf), 
            `subjectId`: try FfiConverterString.read(from: &buf), 
            `sn`: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 6: return .`unrecoverableError`(
            `error`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TapleNotification, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`newSubject`(`subjectId`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`subjectId`, into: &buf)
            
        
        case let .`newEvent`(`sn`,`subjectId`):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(`sn`, into: &buf)
            FfiConverterString.write(`subjectId`, into: &buf)
            
        
        case let .`stateUpdated`(`sn`,`subjectId`):
            writeInt(&buf, Int32(3))
            FfiConverterUInt64.write(`sn`, into: &buf)
            FfiConverterString.write(`subjectId`, into: &buf)
            
        
        case let .`approvalReceived`(`id`,`subjectId`,`sn`):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(`id`, into: &buf)
            FfiConverterString.write(`subjectId`, into: &buf)
            FfiConverterUInt64.write(`sn`, into: &buf)
            
        
        case let .`obsoletedApproval`(`id`,`subjectId`,`sn`):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(`id`, into: &buf)
            FfiConverterString.write(`subjectId`, into: &buf)
            FfiConverterUInt64.write(`sn`, into: &buf)
            
        
        case let .`unrecoverableError`(`error`):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(`error`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTapleNotification_lift(_ buf: RustBuffer) throws -> TapleNotification {
    return try FfiConverterTypeTapleNotification.lift(buf)
}

public func FfiConverterTypeTapleNotification_lower(_ value: TapleNotification) -> RustBuffer {
    return FfiConverterTypeTapleNotification.lower(value)
}


extension TapleNotification: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TapleRequestState {
    
    case `finished`
    case `error`
    case `processing`
}

public struct FfiConverterTypeTapleRequestState: FfiConverterRustBuffer {
    typealias SwiftType = TapleRequestState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapleRequestState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`finished`
        
        case 2: return .`error`
        
        case 3: return .`processing`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TapleRequestState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`finished`:
            writeInt(&buf, Int32(1))
        
        
        case .`error`:
            writeInt(&buf, Int32(2))
        
        
        case .`processing`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeTapleRequestState_lift(_ buf: RustBuffer) throws -> TapleRequestState {
    return try FfiConverterTypeTapleRequestState.lift(buf)
}

public func FfiConverterTypeTapleRequestState_lower(_ value: TapleRequestState) -> RustBuffer {
    return FfiConverterTypeTapleRequestState.lower(value)
}


extension TapleRequestState: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Who {
    
    case `id`(`id`: String)
    case `name`(`name`: String)
    case `members`
    case `all`
    case `notMembers`
}

public struct FfiConverterTypeWho: FfiConverterRustBuffer {
    typealias SwiftType = Who

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Who {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`id`(
            `id`: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .`name`(
            `name`: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .`members`
        
        case 4: return .`all`
        
        case 5: return .`notMembers`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Who, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`id`(`id`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`id`, into: &buf)
            
        
        case let .`name`(`name`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`name`, into: &buf)
            
        
        case .`members`:
            writeInt(&buf, Int32(3))
        
        
        case .`all`:
            writeInt(&buf, Int32(4))
        
        
        case .`notMembers`:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeWho_lift(_ buf: RustBuffer) throws -> Who {
    return try FfiConverterTypeWho.lift(buf)
}

public func FfiConverterTypeWho_lower(_ value: Who) -> RustBuffer {
    return FfiConverterTypeWho.lower(value)
}


extension Who: Equatable, Hashable {}



public enum DbError {

    
    
    // Simple error enums only carry a message
    case KeyElementsError(message: String)
    
    // Simple error enums only carry a message
    case InternalDbError(message: String)
    
}

public struct FfiConverterTypeDbError: FfiConverterRustBuffer {
    typealias SwiftType = DbError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DbError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .KeyElementsError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InternalDbError(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DbError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .KeyElementsError(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .InternalDbError(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension DbError: Equatable, Hashable {}

extension DbError: Error { }


public enum InitializationError {

    
    
    // Simple error enums only carry a message
    case InvalidSettings(message: String)
    
    // Simple error enums only carry a message
    case StartFailed(message: String)
    
    // Simple error enums only carry a message
    case InternalError(message: String)
    
}

public struct FfiConverterTypeInitializationError: FfiConverterRustBuffer {
    typealias SwiftType = InitializationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InitializationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidSettings(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .StartFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .InternalError(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: InitializationError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .InvalidSettings(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .StartFailed(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
        case let .InternalError(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension InitializationError: Equatable, Hashable {}

extension InitializationError: Error { }


public enum NotificationError {

    
    
    // Simple error enums only carry a message
    case NoConnection(message: String)
    
    // Simple error enums only carry a message
    case InternalError(message: String)
    
    // Simple error enums only carry a message
    case LockIsPoisoned(message: String)
    
}

public struct FfiConverterTypeNotificationError: FfiConverterRustBuffer {
    typealias SwiftType = NotificationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .NoConnection(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InternalError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .LockIsPoisoned(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NotificationError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .NoConnection(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .InternalError(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
        case let .LockIsPoisoned(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension NotificationError: Equatable, Hashable {}

extension NotificationError: Error { }


public enum SettingsError {

    
    
    // Simple error enums only carry a message
    case InvalidListenAddr(message: String)
    
    // Simple error enums only carry a message
    case InternalError(message: String)
    
}

public struct FfiConverterTypeSettingsError: FfiConverterRustBuffer {
    typealias SwiftType = SettingsError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SettingsError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidListenAddr(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InternalError(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SettingsError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .InvalidListenAddr(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .InternalError(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension SettingsError: Equatable, Hashable {}

extension SettingsError: Error { }


public enum ShutdownError {

    
    
    // Simple error enums only carry a message
    case InnerLockIsPoisoned(message: String)
    
    // Simple error enums only carry a message
    case InternalError(message: String)
    
}

public struct FfiConverterTypeShutdownError: FfiConverterRustBuffer {
    typealias SwiftType = ShutdownError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShutdownError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InnerLockIsPoisoned(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InternalError(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ShutdownError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .InnerLockIsPoisoned(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .InternalError(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension ShutdownError: Equatable, Hashable {}

extension ShutdownError: Error { }


public enum TapleError {

    
    
    // Simple error enums only carry a message
    case ExecutionError(message: String)
    
    // Simple error enums only carry a message
    case NodeUnavailable(message: String)
    
    // Simple error enums only carry a message
    case NotFound(message: String)
    
    // Simple error enums only carry a message
    case InternalError(message: String)
    
    // Simple error enums only carry a message
    case DigestIdentifierGenerationFailed(message: String)
    
    // Simple error enums only carry a message
    case KeyIdentifierGenerationFailed(message: String)
    
    // Simple error enums only carry a message
    case SignatureIdentifierGenerationFailed(message: String)
    
    // Simple error enums only carry a message
    case InvalidKeyDerivator(message: String)
    
    // Simple error enums only carry a message
    case NoJsonString(message: String)
    
    // Simple error enums only carry a message
    case SignatureGenerationFailed(message: String)
    
    // Simple error enums only carry a message
    case LockIsPoisoned(message: String)
    
    // Simple error enums only carry a message
    case DeserializationError(message: String)
    
    // Simple error enums only carry a message
    case IncorrectGovernanceProperties(message: String)
    
}

public struct FfiConverterTypeTapleError: FfiConverterRustBuffer {
    typealias SwiftType = TapleError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapleError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ExecutionError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .NodeUnavailable(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .NotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .InternalError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .DigestIdentifierGenerationFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .KeyIdentifierGenerationFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .SignatureIdentifierGenerationFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .InvalidKeyDerivator(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .NoJsonString(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .SignatureGenerationFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .LockIsPoisoned(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .DeserializationError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 13: return .IncorrectGovernanceProperties(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TapleError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .ExecutionError(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .NodeUnavailable(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
        case let .NotFound(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
        case let .InternalError(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
        case let .DigestIdentifierGenerationFailed(message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(message, into: &buf)
        case let .KeyIdentifierGenerationFailed(message):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(message, into: &buf)
        case let .SignatureIdentifierGenerationFailed(message):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidKeyDerivator(message):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(message, into: &buf)
        case let .NoJsonString(message):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(message, into: &buf)
        case let .SignatureGenerationFailed(message):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(message, into: &buf)
        case let .LockIsPoisoned(message):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(message, into: &buf)
        case let .DeserializationError(message):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(message, into: &buf)
        case let .IncorrectGovernanceProperties(message):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension TapleError: Equatable, Hashable {}

extension TapleError: Error { }

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate typealias UniFFICallbackHandle = UInt64
fileprivate class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 0
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0

// Declaration and FfiConverters for DatabaseManagerInterface Callback Interface

public protocol DatabaseManagerInterface : AnyObject {
    func `createCollection`(`identifier`: String)  -> DbCollectionInterface
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceDatabaseManagerInterface : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func `invokeCreateCollection`(_ swiftCallbackInterface: DatabaseManagerInterface, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            let result = swiftCallbackInterface.`createCollection`(
                    `identifier`:  try FfiConverterString.read(from: &reader)
                    )
            var writer = [UInt8]()
                FfiConverterCallbackInterfaceDbCollectionInterface.write(result, into: &writer)
                return RustBuffer(bytes: writer)// TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        

        let cb: DatabaseManagerInterface
        do {
            cb = try FfiConverterCallbackInterfaceDatabaseManagerInterface.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("DatabaseManagerInterface: Invalid handle")
            return -1
        }

        switch method {
            case IDX_CALLBACK_FREE:
                FfiConverterCallbackInterfaceDatabaseManagerInterface.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                do {
                    out_buf.pointee = try `invokeCreateCollection`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceDatabaseManagerInterface {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
                ffi_taple_ffi_b33d_DatabaseManagerInterface_init_callback(foreignCallbackCallbackInterfaceDatabaseManagerInterface, err)
        }
    }
    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<DatabaseManagerInterface>()
}

extension FfiConverterCallbackInterfaceDatabaseManagerInterface : FfiConverter {
    typealias SwiftType = DatabaseManagerInterface
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for DbCollectionInterface Callback Interface

public protocol DbCollectionInterface : AnyObject {
    func `get`(`key`: String) throws -> [UInt8]?
    func `put`(`key`: String, `value`: [UInt8]) throws
    func `del`(`key`: String) throws
    func `iter`(`reverse`: Bool, `prefix`: String)  -> DbCollectionIteratorInterface
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceDbCollectionInterface : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func `invokeGet`(_ swiftCallbackInterface: DbCollectionInterface, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            let result = try swiftCallbackInterface.`get`(
                    `key`:  try FfiConverterString.read(from: &reader)
                    )
            var writer = [UInt8]()
                FfiConverterOptionSequenceUInt8.write(result, into: &writer)
                return RustBuffer(bytes: writer)// TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        func `invokePut`(_ swiftCallbackInterface: DbCollectionInterface, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            try swiftCallbackInterface.`put`(
                    `key`:  try FfiConverterString.read(from: &reader), 
                    `value`:  try FfiConverterSequenceUInt8.read(from: &reader)
                    )
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        func `invokeDel`(_ swiftCallbackInterface: DbCollectionInterface, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            try swiftCallbackInterface.`del`(
                    `key`:  try FfiConverterString.read(from: &reader)
                    )
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        func `invokeIter`(_ swiftCallbackInterface: DbCollectionInterface, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            let result = swiftCallbackInterface.`iter`(
                    `reverse`:  try FfiConverterBool.read(from: &reader), 
                    `prefix`:  try FfiConverterString.read(from: &reader)
                    )
            var writer = [UInt8]()
                FfiConverterCallbackInterfaceDbCollectionIteratorInterface.write(result, into: &writer)
                return RustBuffer(bytes: writer)// TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        

        let cb: DbCollectionInterface
        do {
            cb = try FfiConverterCallbackInterfaceDbCollectionInterface.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("DbCollectionInterface: Invalid handle")
            return -1
        }

        switch method {
            case IDX_CALLBACK_FREE:
                FfiConverterCallbackInterfaceDbCollectionInterface.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                do {
                    out_buf.pointee = try `invokeGet`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error as DbError {
                    out_buf.pointee = FfiConverterTypeDbError.lower(error)
                    return -2
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            case 2:
                do {
                    out_buf.pointee = try `invokePut`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error as DbError {
                    out_buf.pointee = FfiConverterTypeDbError.lower(error)
                    return -2
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            case 3:
                do {
                    out_buf.pointee = try `invokeDel`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error as DbError {
                    out_buf.pointee = FfiConverterTypeDbError.lower(error)
                    return -2
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            case 4:
                do {
                    out_buf.pointee = try `invokeIter`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceDbCollectionInterface {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
                ffi_taple_ffi_b33d_DbCollectionInterface_init_callback(foreignCallbackCallbackInterfaceDbCollectionInterface, err)
        }
    }
    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<DbCollectionInterface>()
}

extension FfiConverterCallbackInterfaceDbCollectionInterface : FfiConverter {
    typealias SwiftType = DbCollectionInterface
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for DbCollectionIteratorInterface Callback Interface

public protocol DbCollectionIteratorInterface : AnyObject {
    func `next`() throws -> Tuple?
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceDbCollectionIteratorInterface : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func `invokeNext`(_ swiftCallbackInterface: DbCollectionIteratorInterface, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }
            let result = try swiftCallbackInterface.`next`()
            var writer = [UInt8]()
                FfiConverterOptionTypeTuple.write(result, into: &writer)
                return RustBuffer(bytes: writer)// TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        

        let cb: DbCollectionIteratorInterface
        do {
            cb = try FfiConverterCallbackInterfaceDbCollectionIteratorInterface.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("DbCollectionIteratorInterface: Invalid handle")
            return -1
        }

        switch method {
            case IDX_CALLBACK_FREE:
                FfiConverterCallbackInterfaceDbCollectionIteratorInterface.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                do {
                    out_buf.pointee = try `invokeNext`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error as DbError {
                    out_buf.pointee = FfiConverterTypeDbError.lower(error)
                    return -2
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceDbCollectionIteratorInterface {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
                ffi_taple_ffi_b33d_DbCollectionIteratorInterface_init_callback(foreignCallbackCallbackInterfaceDbCollectionIteratorInterface, err)
        }
    }
    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<DbCollectionIteratorInterface>()
}

extension FfiConverterCallbackInterfaceDbCollectionIteratorInterface : FfiConverter {
    typealias SwiftType = DbCollectionIteratorInterface
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for NotificationHandlerInterface Callback Interface

public protocol NotificationHandlerInterface : AnyObject {
    func `processNotification`(`notification`: TapleNotification) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceNotificationHandlerInterface : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func `invokeProcessNotification`(_ swiftCallbackInterface: NotificationHandlerInterface, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            swiftCallbackInterface.`processNotification`(
                    `notification`:  try FfiConverterTypeTapleNotification.read(from: &reader)
                    )
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        

        let cb: NotificationHandlerInterface
        do {
            cb = try FfiConverterCallbackInterfaceNotificationHandlerInterface.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("NotificationHandlerInterface: Invalid handle")
            return -1
        }

        switch method {
            case IDX_CALLBACK_FREE:
                FfiConverterCallbackInterfaceNotificationHandlerInterface.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                do {
                    out_buf.pointee = try `invokeProcessNotification`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceNotificationHandlerInterface {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
                ffi_taple_ffi_b33d_NotificationHandlerInterface_init_callback(foreignCallbackCallbackInterfaceNotificationHandlerInterface, err)
        }
    }
    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<NotificationHandlerInterface>()
}

extension FfiConverterCallbackInterfaceNotificationHandlerInterface : FfiConverter {
    typealias SwiftType = NotificationHandlerInterface
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeUserGovernance: FfiConverterRustBuffer {
    typealias SwiftType = UserGovernance?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUserGovernance.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUserGovernance.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTapleSignedApprovalResponse: FfiConverterRustBuffer {
    typealias SwiftType = TapleSignedApprovalResponse?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTapleSignedApprovalResponse.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTapleSignedApprovalResponse.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTuple: FfiConverterRustBuffer {
    typealias SwiftType = Tuple?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTuple.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTuple.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUserSubject: FfiConverterRustBuffer {
    typealias SwiftType = [UserSubject]

    public static func write(_ value: [UserSubject], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUserSubject.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UserSubject] {
        let len: Int32 = try readInt(&buf)
        var seq = [UserSubject]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUserSubject.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePolicy: FfiConverterRustBuffer {
    typealias SwiftType = [Policy]

    public static func write(_ value: [Policy], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePolicy.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Policy] {
        let len: Int32 = try readInt(&buf)
        var seq = [Policy]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePolicy.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRole: FfiConverterRustBuffer {
    typealias SwiftType = [Role]

    public static func write(_ value: [Role], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRole.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Role] {
        let len: Int32 = try readInt(&buf)
        var seq = [Role]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRole.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSchema: FfiConverterRustBuffer {
    typealias SwiftType = [Schema]

    public static func write(_ value: [Schema], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSchema.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Schema] {
        let len: Int32 = try readInt(&buf)
        var seq = [Schema]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSchema.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSubjectAndProviders: FfiConverterRustBuffer {
    typealias SwiftType = [SubjectAndProviders]

    public static func write(_ value: [SubjectAndProviders], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSubjectAndProviders.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SubjectAndProviders] {
        let len: Int32 = try readInt(&buf)
        var seq = [SubjectAndProviders]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSubjectAndProviders.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTapleSignature: FfiConverterRustBuffer {
    typealias SwiftType = [TapleSignature]

    public static func write(_ value: [TapleSignature], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTapleSignature.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TapleSignature] {
        let len: Int32 = try readInt(&buf)
        var seq = [TapleSignature]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTapleSignature.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTapleSignedEvent: FfiConverterRustBuffer {
    typealias SwiftType = [TapleSignedEvent]

    public static func write(_ value: [TapleSignedEvent], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTapleSignedEvent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TapleSignedEvent] {
        let len: Int32 = try readInt(&buf)
        var seq = [TapleSignedEvent]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTapleSignedEvent.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringTypeTapleSignature: FfiConverterRustBuffer {
    public static func write(_ value: [String: TapleSignature], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeTapleSignature.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: TapleSignature] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: TapleSignature]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeTapleSignature.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

public func `start`(`manager`: DatabaseManagerInterface, `settings`: TapleSettings) throws -> TapleNode {
    return try FfiConverterTypeTapleNode.lift(
        try
    
    rustCallWithError(FfiConverterTypeInitializationError.self) {
    
    taple_ffi_b33d_start(
        FfiConverterCallbackInterfaceDatabaseManagerInterface.lower(`manager`), 
        FfiConverterTypeTapleSettings.lower(`settings`), $0)
}
    )
}



public func `generateKey`(`keyDerivator`: TapleKeyDerivator)  -> [UInt8] {
    return try! FfiConverterSequenceUInt8.lift(
        try!
    
    rustCall() {
    
    taple_ffi_b33d_generate_key(
        FfiConverterTypeTapleKeyDerivator.lower(`keyDerivator`), $0)
}
    )
}



/**
 * Top level initializers and tear down methods.
 *
 * This is generated by uniffi.
 */
public enum TapleFfiLifecycle {
    /**
     * Initialize the FFI and Rust library. This should be only called once per application.
     */
    func initialize() {
    }
}